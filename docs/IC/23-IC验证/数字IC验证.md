

验证就是验证设计实现是否与设计意图相符，也就是说发现设计人员的错误；
验证的过程是保证芯片实现符合规格说明书（specification，系统的spec，ip的spec等）的过程
 数字验证： ![[docs/IC/20-IC设计流程/attachments/Pasted image 20230322165020.png]]
 ## 数字IC中的验证岗位
 ![[docs/IC/20-IC设计流程/attachments/Pasted image 20230322165518.png|800]]
 
 验证是确保设计和预定的设计期望一致的过程，设计期望通常是通过设计规范来定义的。对于芯片设计，在不同的阶段可以分为：寄存器传输级（RTL）的功能验证、门级的仿真验证、形式验证以及时序验证。我们通常所说的验证一般是指 RTL 验证。

## 芯片验证的意义
*芯片验证存在的意义在于不断地给设计或者实现过程提供迭代的指导意见，即验证过程发现的性能不满足、设计代码功能 bug、整芯片集成错误等问题。*  随着项目进度的推进，芯片本身的表现形式会发生变化，从 RTL 代码、到各种网表，再到最后的版图。在这个过程中，芯片验证可以分为前仿真（基于 RTL 代码）和后仿真（基于门级网表）。主要的设计问题都应该在前仿真的时候就暴露出来，毕竟越到后面设计的迭代成本越高，风险也会越大。
**对于一名验证工程师而言，他需要充分理解系统验证的全过程，这个过程就是功能验证的生命周期**。

## 芯片的测试流程
当细分的合适大小模块初步完成 RTL 级（寄存器级别，Register Transistor Level）的硬件描述语言文件之后，功能验证人员会在这个时候做几项工作来检查硬件设计：
1. HDL 硬件描述文件是否正确按照功能描述文档去实施了？
2. 硬件设计人员是否有遗漏掉的额外情况（corner case）？
3. 硬件设计是否足够稳定来处理一些错误的情况（error response）？

实际项目中，**硬件设计人员和功能验证人员的合作是紧密的**，这具体表现在了：
1. 当系统设计团队将功能需求翻译为功能描述以后，硬件设计团队和功能验证团队需要围绕着功能描述文档分别展开硬件设计和功能验证工作。
2.  硬件设计团队在初步翻译出硬件描述文件以后，功能验证团队需要将硬件描述文件搭建验证环境展开各个功能点的验证。
3.  当验证环境测试出实际结果与预期结果不符合的情况下可以分为
	1. 如果硬件设计与功能描述文档存在明显不符时，功能验证人员会报告出存在的设计缺陷，同时硬件设计人员会修复硬件描述文件，这样从验证到设计再转回到验证即完成一个缺陷检测和修正周期。
	2. 当实际结果和预期结果有模糊的边界时（例如时序问题，状态机跳转问题），验证人员和设计人员会就同一份功能描述文件的理解存在分歧，此时他们会做初步的讨论，来确定哪一方的理解有偏差。当讨论依旧无法判定理解分歧的时候，双方最终会找到系统设计人员进行“裁决”，来明确本来的系统设计思想，进而统一双方对功能描述的理解。
因此，硬件设计的完成度和缺陷率会在设计人员和验证人员的迭代周期中不断得到完善，最终达到目标。关于功能验证目标的定义，我们会在以后的文章“验证的任务和目标”详细讲述。

当功能验证完成以后，后端人员会将 RTL 文件综合生成门级网表文件（gate netlist），同时也会为了目标速度来进行布局布线，最终可以使得门级电路可以在设定的时钟频率上面工作。在后端的各种流程当中，与前端验证人员联系紧密的当属标准延时格式（SDF，Standard Delay Format）文件，该文件会包含门级网表中各个门单元之间的延时情况用来准确描述实际电路。

所以，对于功能验证流程而言，我们所说的仿真可以根据项目的实施流程将其划分为前端仿真和后端仿真：
1.  **前端仿真**指的是进行RTL仿真，在这种仿真当中是没有真实延时情况的。对于一个寄存器（register），它的输出端（Q port）相对它的时钟输入端（Clk port）的延时为零延时（delta delay）。
2.  **后端仿真**指的是进行 Gate 仿真。在实际项目中，由于后端综合进而产生 SDF 文件本身需要不断迭代周期，我们进一步又将门级仿真划分为零延时仿真和 SDF 仿真。
	1. **零延时仿真**是只有门级网表参与仿真，没有 SDF 文件来具体反向标注（back annotation）门级延时情况，所以门之间的延时仍然为零延时，这个时候门级零延时仿真与 RTL 仿真的区别仅在于前者是后者的逻辑映射，从寄存器级别到门级的逻辑转译，这一步是由后端的综合工具（synthesis tooling）完成的。
	2. 当后端随后产生出 SDF 文件时，我们会将门级网表反向标注上 SDF 文件中包含的每一条门单元之间路径的延时，最终进行有真正**延时电路的仿真**。
从验证完整性而言，前端仿真和后端仿真均需要在项目中实施，而它们侧重的目标也有不同。**前端仿真是为了检测出功能逻辑的缺陷，而后端仿真是为了检测出实际门级电路中由于延时问题可能导致采样失败进而产生的功能缺陷。** 也因此验证人员不能将前端仿真的功能缺陷检测任务下移到后端仿真阶段，因为就效率问题而言，前端仿真要显著高于后端仿真；同时，后端仿真之所以不能忽略是因为它可以协助后端人员来测试出实际生成电路中是否有时序不满足的问题。

当完成后端仿真以后，我们会将后端生成的标准格式文件最终交付给芯片生产商进行流片（tape out）。从上面的描述来看，**这是一个完整的芯片从定义、分块、设计、验证和后端的硅前（pre-silicon）流程，同时芯片在流片以后所面临的硅后流程（post-silicon）也是一个完整的周期，这其中包括了组件测试，驱动，系统固件和应用软件编写等等**。由于功能验证处在硅前流程当中，我们在这里主要阐述该流程，同时，我们也将一些相对独立的部分略去（这并不代表它们不重要），例如可测试性设计（DFT，Design for Test）。

至此，芯片的硅前流程就结束了。考虑到验证人员同设计人员在实际工作中的密切结合，我们举出一个生活中的例子来情景演绎出设计验证流程是如何进行的。
![[docs/IC/20-IC设计流程/attachments/Pasted image 20230322170004.png]]

---
芯片验证也会有很多分类，根据芯片类型的不同可以分为：CPU验证、GPU验证、TPU验证、NPU验证、SoC验证等等；


据工具的不同可以分为EDA验证、FPGA原型验证、Emulator验证：

EDA验证即功能验证，根据开发的不同阶段分为前仿验证和后仿验证。主要工具有VCS、Verdi、NC-Verilog、ModelSim等等。EDA验证是通过软件仿真来验证电路设计的功能行为，是比较理想情况下的，没有考虑电路内部逻辑与互连的延时。优点是波形直观，能够快速找出功能bug，性价比高，缺点是仿真速度慢，难以对整个芯片系统进行验证。

FPGA原型验证即编译设计代码，并且综合为真实的硬件电路对应FPGA板子上去，通过真实的硬件电路进行仿真(FPGA原型)。FPGA原型验证，将RTL代码移植到FPGA来验证IC系统的功能和性能。基本流程：将ASIC代码转换成FPGA代码，编译与对设计拆分，综合，布局布线，生成比特流文件bitfile。优点是降低了软硬件协同验证的成本，加速了硬件验证和软件开发；缺点是编译较慢，设计拆分时易出错，比较难定位bug。

通常认为Emulator验证为介于simulator和FPGA prototyping间的产物，同时拥有二者的优点，如方便debug波形、可使用force/release命令、检查覆盖率、打印display信息、同时运行速度快很多，最大的缺点就是太贵了，需要时间和人力去搭建环境和维护。Cadence的Palladium、Mentor Graphics的Veloce，以及Synopsys的ZeBu等平台。

根据层次不同可以分为模块验证、子系统验证、系统验证：

模块验证：侧重点在模块本身功能的验证，验证计划的重点是feature和验证架构，然后列出testcase，模块能够覆盖的绝不到下一级验证去覆盖。主要内容有：检查参数设置、寄存器读写、协议检查、中断和复位、状态机跳转、工作模式覆盖、RAM的读写功能边界等等。

子系统验证：侧重点在系统的互联性，更加关注系统的工作模式和复杂场景应用。主要内容有：中断的产生、DMA功能、IP的模式功能、Memory读写等等。

系统验证：侧重点在软硬件协同仿真，关键系统路径的覆盖，芯片工作模式和测试模式以及数据通路和性能等。主要内容有：基本IP功能、CLK/RESET、IO MUX 、多个IP同时工作、程序的启动、工作模式和应用场景测试。

根据可见度可分为黑盒验证、灰盒验证和白盒验证等等。

黑盒验证：验证的输入只有输入信号，输出信号和相应的功能。不需要关心内部信号和架构，验证代码对DUT内部的更改不太敏感。常用于大规模的系统级验证。

白盒验证：验证的输入有输入信号，输出信号，内部信号，所有的信号时序和相应的功能。需要了解实际的实现方式，能够阅读RTL设计代码。常用于模块级别验证。

灰盒验证：黑盒验证和白盒验证的结合体，这使得验证环境的开发更加灵活。常用于子系统级别验证。

---


## 验证完备性
### 1.项目周期
来到芯片验证本身，如何保证芯片验证的完备性是一个需要不断思考的问题。这里应该有一个时间和资源的限制前提，否则大规模芯片的验证工作是可以一直做下去的，直到天荒地老海枯石烂。

### 2.spec理解+Feature提取+测试点补充
芯片验证的完备性的保障需要建立在对需求规格的充分理解上，凭借经验和一些惯用技巧从规格中提取出测试点，结合既往项目的案例分析和团队的头脑风暴对测试点进行必要增补。上面一段话讲得相当含糊，那是因为这件事本身就没有标准答案。

### 3.覆盖率验证+回归验证->迭代验证
有了测试点之后，还要看针对测试点的覆盖情况。测试点一般通过测试用例来实现覆盖，当然也可以直接肉眼检查代码、人脑分析逻辑，但不建议这么做，毕竟一般人是不敢保证自己不会看走眼或大脑分析不会出错，再则这方法复用性极差。这个时候你可能会问，难道一般人就能保证测试用例写得没问题？到了这里，千万不要说这个用例是项目继承的或者是其他人写的，而应该对自己负责的用例很熟悉，可以通过仿真波形或者请求小伙伴检视用例本身是不是埋藏了某些bug。

最后一步逻辑，就是怎么保证你的测试用例确实执行了，并且回归都过了。这个问题比较好把握，有就是有，没有就是没有，覆盖率、仿真日志或者回归报告等都可以用来回答该问题。

## 验证效率
芯片开发中设计人员和验证人员的配比应该是1:2，甚至1:3.(肯定设计同学不乐意了。哈哈。。。)。事实确实如此！所以验证效率尤其重要。

### 验证流程管理
一个完善的高效的验证流程是保证验证效率和验证质量，顺利推进验证进度的必要条件。这个流程一般指的是验证进度的安排、验证事项的优先级划分、验证过程的监管措施、验证质量的评审制度等。当然，流程的建设也是一个实践的过程，它不应该只是一个PPT流程或口头流程。

### 人力资源的调配
根据不同项目进度、事项优先级和人员素质，合理安排人力资源的投入，能够有效推进项目进度。通常在多个项目并行的情况下，人力资源的及时调配会显得相当重要。

### 验证资源的复用
得益于UVM等验证方法和验证框架的成熟发展，验证环境通常可以在多个项目之间复用。除此之外，测试用例和流程脚本也是比较有效的复用资源，而且有时候还会开发一些in-house的自动化工具来提高工作效率。因此，验证工程师在开发验证组件的时候就需要考虑这些资源的可维护性和可移植性，即具备“封装”的能力。

## 验证收敛
一切工作都以项目Teapoout为导向，作为验证的话，则以“验证收敛”为终极目标。

## 覆盖率
### 代码覆盖率
代码覆盖率是用来评估代码的执行情况，一般是通过工具自动化统计代码中分支语句、状态转换、信号翻转等代码的执行情况，是一种定量度量。

### 功能覆盖率
功能覆盖率是对代码执行情况的定性分析，它的全集来自于上面介绍完备性的时候提到的验证计划，表征验证计划的具体覆盖情况。

代码覆盖率+功能覆盖率相辅相成，可以结合起来粗略判断是代码有过多冗余还是验证计划存在遗漏。

### 断言覆盖率

最后的断言覆盖率指的是对代码中定义的属性（property）的覆盖情况统计，一般用来监测代码中特定的信号时序关系或者逻辑关系。可由设计人员和验证人员编写。

## 验证方法学
不单单是指UVM。UVM提供了TB框架和类库等资源。

基于覆盖率驱动的验证方法（Coverage Driven Verification Methodology），它是对验证进度和验证质量的一种评估机制，并以此作为驱动。

覆盖率驱动的验证方法通常有两种类型。第一种是基于约束的随机验证（Constrained Random），第二种是基于图的激励生成（Intelligent Testbench）。前者相对比较常见，通常是从随机激励开始，然后逐渐缩紧约束，直到覆盖率达到验证目标；后者通常需要依赖于专用的工具，基于对DUT的高级抽象描述来缩小随机空间，进而更加高效的产生随机激励。这两种方法过程不同，但它们最终都是以覆盖率作为评估标准。

覆盖率驱动的验证方法是一套较为“理想化”的方法学，它明确了用什么覆盖率来度量验证工作并判断验证工作是否足够完善。在实际应用中，很难直接一上来就开大随机进行仿真，而是会根据不同的功能业务来缩小随机范围，甚至会把定向用例放到前面来把一些重要的测试点首先覆盖，扫除一些低级bug。因此，针对不同的项目情况因地制宜地调整验证方法，可以在根本上提高验证的效率。


---
[(3条消息) IC验证概念总结_weixin_30371875的博客-CSDN博客](https://blog.csdn.net/weixin_30371875/article/details/97326062)
