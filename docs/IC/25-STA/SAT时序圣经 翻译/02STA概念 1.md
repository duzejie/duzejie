---
title: 第二章：STA概念
author: Sunglow
top: false
cover: false
toc: false
mathjax: false
summary: 'null'
categories:
  - 集成电路
  - 时序分析
tags:
  - 集成电路
  - 时序分析
date: 2018-02-21 21:25:13
keywords:
---

<div>
<style>
img{
    width: 60%;
    max-width:500px;
    //padding-left: 20%;
}
</style>
</div>


# 第二章：STA概念



## 2.1 CMOS逻辑设计

## 2.1.1 基本MOS结构

MOS晶体管（NMOS和PMOS）的物理实现如图2-1所示。源极（source）和漏极（drain）区域之间的距离（channel length）是MOS晶体管的长度，`用于构建MOS晶体管的最小长度即为CMOS技术工艺的最小特征尺寸（feature size）`。例如，0.25um技术允许制造具有0.25um或更大沟道长度的MOS晶体管。 通过缩小沟道的几何形状，晶体管的尺寸会变小，这样就可以在同样的面积上封装更多的晶体管。 正如我们将在后面章节看到的那样，更小的晶体管尺寸同样还可以使设计以更高的速度运行。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-070e61013ed37659190f2d60e30460b4_1440w.jpg)图2-1

## 2.1.2 CMOS逻辑门

CMOS逻辑门使用NMOS和PMOS晶体管搭建而成。图2-2给出了CMOS反相器（inverter）的示例。CMOS反相器有两种稳定状态，具体取决于输入的电平状态。 当输入A为低电平（Vss或逻辑0）时，NMOS晶体管截止，而PMOS晶体管导通，导致输出Z的电平被上拉至逻辑为1的Vdd。当输入A为高电平（Vdd或逻辑1）时，NMOS晶体管导通，而PMOS晶体管截止，导致输出Z的电平被下拉至逻辑为0的Vss。在上述两种状态中的任何一种状态下，CMOS反相器都是稳定的，不会从输入端A或电源Vdd汲取任何电流。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-29854db71935530a41bbc14294e8e2f1_1440w.jpg)

图2-2

CMOS反相器的特性可以扩展到任何CMOS逻辑门。在CMOS逻辑门中，输出节点通过上拉结构（由PMOS晶体管构成）连接至Vdd，并通过下拉结构（由NMOS晶体管构成）连接至Vss。例如，图2-3展示了一个两输入CMOS与非门（nand）。在该例中，上拉结构由两个并联的PMOS晶体管组成，下拉结构由两个串联的NMOS晶体管组成。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-e56ce42dd76f7ec56ac66d4e2a2705fc_1440w.jpg)

图2-3

对于任何CMOS逻辑门，上拉和下拉结构是互补的。对于逻辑0或逻辑1的输入，如果上拉结构开启，则下拉结构将关闭；类似地，如果上拉结构关闭，则下拉结构将开启。下拉和上拉结构由CMOS门实现的逻辑功能控制。例如，在CMOS与非门中，控制下拉结构的功能是“A&B”，即当A和B都为逻辑1时下拉被接通。类似地，控制上拉结构的功能是“ $$ \overline A | \overline B$$”，即当A或B处于逻辑0时上拉被打开。这些特性确保了控制上拉结构的功能将输出节点的逻辑上拉至Vdd。由于下拉结构由互补函数控制，因此当上拉结构函数的值为0时，输出节点处于逻辑0。

对于逻辑0或逻辑1的输入，由于上拉和下拉结构不能同时开启，因此处于稳态的CMOS逻辑门不会对输入或电源汲取任何电流。CMOS逻辑的另一个重要方面是，输入仅对前一级构成容性负载。

若CMOS逻辑门是一个反相门，这意味着单个输入的变化（上升或下降）只能使输出往相反的方向改变，也就是说，输出无法与输入同相变化。但是，可以将CMOS逻辑门级联起来以实现更复杂的逻辑功能。

## 2.1.3 标准单元

芯片中的大多数复杂功能通常是使用基本构建块（basic building block）来设计的，这些基本构建块实现了简单的逻辑功能，例如与、或、与非、或非、或与非，与或非以及触发器（flip-flop）。这些基本构建块是预先设计的，称为标准单元（standard cell）。标准单元的功能和时序已预先确定，可供设计人员使用。然后，设计人员可以使用标准单元作为基本构建块来实现所需的功能。

前面小节中描述的CMOS逻辑门的关键特性适用于所有CMOS数字设计。当输入处于稳定的逻辑状态时，所有数字CMOS单元的设计都能够保证不从电源汲取电流（漏电流除外）。因此，大多数功耗与设计的功能有关，并且是由设计中CMOS单元输入端的充放电引起的。

什么是逻辑1或逻辑0？在CMOS单元中，VIHmin和 VILmax这两个值定义了范围：高于VIHmin的电压值被认为是逻辑1，低于VILmax的电压值被认为是逻辑0。如图2-4所示，0.13um工艺下一个具有1.2V Vdd电源的CMOS反相器单元的典型VILmax值为0.465V、VIHmin值为0.625V。 VIHmin和VILmax的值是从标准单元的直流传输特性中得出的。直流传输特性会在接下去的6.2.3节中有更详细的描述。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-0e18512fef5ac668ab1dcb929bc75a8b_1440w.jpg)图2-4

## 2.2 CMOS单元建模

如果一个单元的输出引脚驱动多个扇出单元，则该单元的输出引脚上的总电容等于该单元正在驱动的单元的所有输入电容的总和加上构成该网络所有走线电容之和再加上驱动单元的输出电容。注意，在CMOS单元中，输入引脚仅呈现电容性负载。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-6ec63472a1bd9be52546be8c7e189b1f_1440w.jpg)

图2-5

图2-5是一个单元G1驱动其他三个单元G2、G3和G4的示例。 Cs1，Cs2，Cs3和Cs4是组成该网络的走线电容值，因此G1输出引脚的总电容=G2单元的输入电容+G3单元的输入电容+G4单元的输入电容+G1单元的输出电容+ Cs1+Cs2+Cs3+Cs4 。这个值就是G1单元进行电平切换时需要充放电的电容值，因此该总电容值会影响G1单元的时序特性。

从时序角度来看，我们需要对CMOS单元建模，以帮助我们分析通过该单元的时序。每个输入引脚必须指定一个输入引脚电容，而大多数CMOS逻辑单元可以不包括输出引脚的引脚电容，但也可能存在输出引脚电容。

当输出为逻辑1时，输出级的上拉结构导通，并提供了一条从输出到Vdd的路径。同样，当输出为逻辑0时，输出级的下拉结构提供了一条从输出到Vss的路径。当CMOS单元切换电平状态时，切换的速度取决于输出引脚上的电容被充放电的速度。输出引脚上的电容（图2-5）分别通过上拉和下拉结构充电和放电。注意，上拉和下拉结构中的通道会对输出的充放电路径构成电阻，充放电路径的电阻是决定CMOS单元速度的主要因素。`上拉电阻的倒数称为单元的输出高电平驱动（output high drive）`。输出上拉结构越大，上拉电阻就越小，即单元的输出高电平驱动就越大，较大的输出结构也意味着该单元的面积较大。而输出上拉结构越小，单元的面积就越小，其输出高电平驱动也就越小。上拉结构的相同概念可用于下拉结构，下拉结构决定了下拉路径的电阻值以及`输出低电平驱动（output low drive）`。通常，单元的上拉和下拉结构具有相似的驱动强度。

输出驱动决定了可以驱动的最大电容负载，最大电容负载又决定了扇出的最大数量，即可以驱动多少个其他单元。较高的输出驱动对应较低的输出上拉/下拉电阻，这使单元可以在输出引脚上对较大的负载进行充电和放电。

下图2-6是CMOS单元的等效抽象模型。该模型的目的是抽象单元的时序行为，因此仅对输入级和输出级进行建模，此模型无法捕获单元的固有延迟或电学行为。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-bf581fb2b21db0ec50e11bb33c872ff1_1440w.jpg)

图2-6

$C_{pinA}$是单元在输入A上的输入引脚电容；Rdh和Rdl是单元的输出驱动电阻，可根据单元所驱动的负载确定输出引脚Z电平转换时的上升/下降时间，输出驱动电阻还确定了单元的最大扇出限制。

图2-7与图2-5具有相同的网络，但使用等效模型表示了CMOS单元：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-68c7436ae3443380e16b6f8a371c2a19_1440w.jpg)

图2-7

 ● Cwire = Cs1+Cs2+Cs3+Cs4

 ● 输出充放电延迟 = Rout × （Cwire + Cin2 + Cin3 + Cin4）

在上述表达式中，Rout是Rdh或Rdl之一，其中Rdh是上拉的输出驱动电阻，Rdl是下拉的输出驱动电阻。

## 2.3 电平切换波形

如图2-8（a）所示，通过按下SW0开关将电压施加到RC网络时，输出将变为逻辑1。假设还未按下SW0时输出为0V，则输出电压的变化由以下公式表示：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-8a6c974eb8d994950fb689151ecba308_1440w.png)

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-80b95f14292cb28be9a2048f262b9ccd_1440w.jpg)

图2-8

该上升的电压波形如图2-8（b）所示。`乘积（Rdh * Cload）称为RC时间常数（RC time constant）`，该值与输出的过渡时间有关。

断开SW0开关同时按下SW1开关，输出就会从逻辑1变为逻辑0，输出电压的变化如图2-8（c）所示。输出电容通过按下的SW1开关放电，这种情况下的电压变化由以下公式表示：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-7866eb36a5736a53ddb7e0cd2b8c4166_1440w.png)

在CMOS单元中，由于PMOS上拉晶体管和NMOS下拉晶体管在短时间内会同时导通，因此输出的充放电波形不会像图2-8的RC充放电波形那样。 图2-9显示了在CMOS反相器单元内，从逻辑1到逻辑0输出切换时各个阶段的电流路径。图2-9（a）显示了当上拉和下拉结构同时开启时的电流流动。随后，上拉结构关闭，电流流向随即如图2-9（b）中所示。输出达到最终状态后，由于电容Cload已完全放电，因此不再有电流流动。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-e35127deebe216a697d5ddacb06db06f_1440w.jpg)

图2-9

图2-10（a）是CMOS单元输出级的典型波形，请注意观察过渡波形如何逐渐朝向Vss和Vdd弯曲，且波形的线性部分位于中间位置。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-dcae7a88ee6024498fd3467119ba444a_1440w.jpg)

图2-10

在本文中，我们将使用如图2-10（b）所示的简化版来描绘一些波形，简化版的近似波形也是具有一定过渡时间（transition time）的波形，过渡时间是指从一种逻辑状态过渡到另一种逻辑状态所需的时间。图2-10（c）是过渡时间为0的波形，即理想波形。我们将在本文中交替使用（b）（c）这两种形式的波形来解释一些概念，但我们一定要清楚，实际上每个波形都有（a）那样的真实的边缘特性。

## 2.4 传播延时

考虑一个CMOS反相器单元及其输入和输出波形，单元的`传播延时（propagation delay）`是由电平切换波形上的某些测量点定义的。使用以下四个变量定义这些测量点：

 #输入端口下降沿的阈值点

 **input_threshold_pct_fall**：50.0；

 #输入端口上升沿的阈值点

 **input_threshold_pct_rise**：50.0；

 #输出端口下降沿的阈值点

 **output_threshold_pct_fall**：50.0；

 #输出端口上升沿的阈值点

 **output_threshold_pct_rise**：50.0；

以上这些变量是用于描述单元库（cell library）的命令集里的一部分。 这些阈值的单位是Vdd或电源的百分比，对于大多数标准单元库，通常将50％阈值用于计算延时。

上升沿是指从逻辑0到逻辑1的跳变，下降沿是从逻辑1到逻辑0的跳变。

假设有一个CMOS反相器单元，其输入输出管脚的波形如图2-11所示，传播延时是指如下两个值：

 1.输出下降沿延时（output fall delay）：Tf

 2.输出上升沿延时（output rise delay）：Tr

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-f457a18b69930fddbac8dc41db072768_1440w.jpg)

图2-11

通常，这两个值是不相等的，上图2-11也展示了这两个传播延时值是如何测量的。

若使用理想波形来看，则传播延时将仅仅是两个边沿之间的延迟，如图2-12所示：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-c019718f9a474a09442d3a4fb6b254d3_1440w.jpg)

图2-12



## 2.5 波形的压摆

压摆率（slew rate）的定义是电压转换速率。在静态时序分析中，通常会根据电平转换的快慢来衡量上升波形或下降波形。 压摆（slew）通常是根据转换时间（transition time）来定义的，转换时间是指信号在两个特定电平之间转换所需要的时间。请注意，转换时间实际上就是压摆率的倒数，因此转换时间越大，压摆率就越低，反之亦然。

回顾图2-10给出的CMOS单元输出端典型波形：靠近Vdd和Vss两端的波形是渐近的，很难确定过渡时间的确切起点和终点。因此，一般使用指定的阈值电压来规定过渡时间计算的起点和终点。例如，压摆阈值设置可以如下所示：

 #下降沿的阈值点

 **slew_lower_threshold_pct_fall**：30.0；

 **slew_upper_threshold_pct_fall**：70.0；

 #上升沿的阈值点

 **slew_lower_threshold_pct_rise**：30.0；

 **slew_upper_threshold_pct_rise**：70.0；

以上这些数值的单位同样是Vdd的百分比。阈值设置指定了下降压摆（Fall slew）为下降沿达到Vdd的70％和30％的时间之差。类似地，设置指定了上升压摆（Rise slew）为上升沿达到Vdd的30％和70％的时间之差，如图2-13所示：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-31d562c5a5c9c8ca6b00bd339863175b_1440w.jpg)图2-13

图2-14是另一个示例，其中下降沿的压摆测量范围为80％至20％，而上升沿的压摆测量范围为10％至90％，以下是这个例子的阈值设置：

 #下降沿的阈值点

 **slew_lower_threshold_pct_fall**：20.0；

 **slew_upper_threshold_pct_fall**：80.0；

 #上升沿的阈值点

 **slew_lower_threshold_pct_rise**：10.0；

 **slew_upper_threshold_pct_rise**：90.0；

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-12cbcf0dd30d312a27bb761cbf4d6286_1440w.jpg)

图2-14

## 2.6 信号偏斜

偏斜（skew）是指两个或多个信号（数据或者时钟）之间的时序之差。例如，如果一个时钟树（clock tree）有500个终点，并且有50ps的偏斜，则意味着最长时钟路径和最短时钟路径之间的延迟差为50ps。如图2-15所示是一个时钟树，时钟树的起点通常是定义时钟的节点，时钟树的终点通常是同步元件（例如触发器）的时钟引脚。时钟延迟（clock latency）是指从时钟源到终点所花费的总时间，时钟偏斜（clock skew）是指到达不同时钟树终点的时间差。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-9bfb081b8498595ee7952cb61153cfad_1440w.jpg)

图2-15

理想时钟树是假定时钟源具有无限驱动力，也就是说，时钟可以无延迟地驱动无限个终点。另外，假定时钟树中存在的任何逻辑单元都具有零延迟（zero delay）。 在逻辑设计的早期阶段，STA通常使用理想的时钟树来执行，因此分析的重点是数据路径（data path）。在理想的时钟树中，默认情况下时钟偏斜为0ps，可以使用**set_clock_latency**命令显式地指定时钟树的延迟：

**set_clock_latency** 2.2 [**get_clocks** BZCLK]

上述命令规定了时钟树BZCLK的上升沿延迟（rise latency）和下降沿延迟（fall latency）均为2.2ns。注意，如果两个延时值不同，可以使用选项**-rise**和**-fall**来分别指定延时值。

时钟树的`时钟偏斜`可以借助**set_clock_uncertainty**命令显式指定时钟不确定度的值来进行描述：

**set_clock_uncertainty** 0.250 **-setup** [**get_clocks** BZCLK] 

**set_clock_uncertainty** 0.100 **-hold** [**get_clocks** BZCLK]

**set_clock_uncertainty**命令为时钟沿的出现指定了一个窗口。时钟边沿时序的不确定性将考虑多个因素，例如时钟`周期抖动（jitter）`和用于时序验证的额外`裕量（slack）`。每个实际的时钟源都有一定的抖动量，即一个时间窗口，在该窗口内都可能会出现时钟沿。时钟周期抖动取决于所使用的时钟发生器的类型。实际上是不存在理想时钟的，也就是说，所有时钟都具有一定的抖动量，并且在指定`时钟不确定度（clock uncertainty）`时应包括时钟周期抖动。

在时钟树被实现（implement）之前，时钟不确定度还必须包括预期的时钟偏斜。

可以为建立时间（setup time）检查和保持时间（hold time）检查指定不同的时钟不确定度。保持时间检查不需要将时钟抖动包括在内，因此通常为保持时间检查指定较小的时钟不确定度。

如下图2-16所示是时钟不确定度为250ps的建立时间检查。图2-16（b）揭示了时钟不确定度是如何从逻辑传播到下一个触发器的耗时中消去的，这相当于要验证设计能够以更高的频率运行。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-48609c4e609f654f7f3f14b5ef98cd3d_1440w.jpg)图2-16

如上所述，**set_clock_uncertainty**命令也可以用于建模任何额外时序裕量。例如，设计人员可以在设计过程中依据一定的悲观度而设置50ps的时序裕量，使用**set_clock_uncertainty**命令时会将这个值加进去。

总而言之，在实现时钟树之前，**set_clock_uncertainty**命令指定的值将包括时钟抖动、时钟偏斜估计值以及额外悲观度。

**set_clock_latency** 2.0 [**get_clocks** USBCLK] 

**set_clock_uncertainty** 0.2 [**get_clocks** USBCLK]

上面这条命令中200ps的时钟不确定度可能是由50ps时钟抖动、100ps时钟偏斜以及50ps的额外悲观度组成的。

随后我们将看到**set_clock_uncertainty**这条命令是如何影响建立时间和保持时间检查的，我们最好能够将时钟不确定度视为最终计算时序裕量（slack）的补偿（offset）。

## 2.7 时序弧

每个逻辑单元都有多个时序弧（timing arc）。像与门、或门、与非门、加法器这些组合逻辑单元，每个输入引脚到每个输出引脚都存在一条时序弧。而像触发器之类的时序逻辑单元除了有从时钟引脚到输出引脚的时序弧，还有相对于时钟引脚的数据引脚时序约束（timing constraint）。每个时序弧都具有特定的时序敏感（timing sense），即输出如何针对输入的不同跳变类型而变化。如果输入引脚上的上升沿跳变导致输出引脚电平上升（或不变），而输入引脚上的下降沿跳变导致输出引脚电平下降（或不变），则时序弧为`正单边（positive unate）`类型。 例如,与门和或门的时序弧为正单边类型，如下图2-17（a）所示：

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-89d9671135e476cca5b55076bca73889_1440w.jpg)

图2-17

如果输入引脚上的上升沿跳变导致输出引脚电平下降（或不变），而输入引脚上的下降沿跳变导致输出引脚电平上升（或不变），则时序弧为`负单边（negative unate）`类型。例如，与非门和或非门的时序弧为负单边类型，如上图2-17（b）所示。

在`非单边（non-unate）`时序弧中，仅仅从一个输入引脚的跳变方向是无法确定输出引脚电平将如何跳变的，还要取决于其他输入引脚的状态。例如，异或门中的时序弧是非单边时序弧，如上图2-17（c）所示。

单边性（unateness）对于时序很重要，因为它指定了输入引脚上电平跳变沿将如何通过逻辑单元传播以及将如何出现在逻辑单元的输出引脚上。

`可以利用时序弧的非单边性（如异或门）来反转时钟的极性（polarity）`。如下图2-18所示，如果输入POLCTRL为逻辑0，则单元UXOR0的输出上的时钟DDRCLK具有与输入时钟MEMCLK相同的极性。如果POLCTRL为逻辑1，则单元UXOR0的输出时钟的极性与输入时钟MEMCLK的极性相反。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-3f99b501c3bc3225b3df9e7c83298e41_1440w.jpg)

图2-18

## 2.8 最小与最大时序路径

逻辑通过逻辑路径传播的总延迟称为路径延迟（path delay），包括了逻辑路径中经过各个逻辑单元（cell）和网络走线（net）的延迟。通常，逻辑想要传递到一个终点可能有不止一条逻辑路径可走，所经过的实际路径取决于逻辑路径上其他输入的状态。图2-19给出了一个例子，由于有多个到达逻辑终点的路径，因此可以得出到达逻辑终点的最大时序和最小时序，对应于最大时序和最小时序的路径分别称为最大路径和最小路径。两个节点之间的最大路径是指延迟最大的路径（也称为最长路径），同样，最小路径是指延迟最小的路径（也称为最短路径）。请注意，最长和最短是指路径上的累积延迟，而不是路径上的逻辑单元个数。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-cd6e801dc8d46b8ac0a01cfc4674130a_1440w.jpg)

图2-19

图2-19给出了两级触发器之间数据路径的示例。可以看到经过UNAND0、UBUF2、UOR2和UNAND6单元的路径是触发器UFF1和UFF3之间的最大路径，而经过UOR4和UNAND6单元的路径是触发器UFF1和UFF3之间的最小路径。请注意，本例中所说的最小与最大时序路径都是基于终点是触发器UFF3的D引脚。

通常也称最大路径为`晚路径（late path）`，称最小路径为`早路径（early path）`。

当考虑从UFF1到UFF3这样的从触发器到触发器的路径时，其中一个触发器发起（launch）数据，另一个触发器捕获（capture）数据。在这种情况下，由于UFF1发起数据，因此UFF1被称为发起触发器（launch flip-flop），由于UFF3捕获数据，因此UFF3被称为捕获触发器（capture flip-flop）。请注意，“发起”和“触发”不是绝对的，一定是相对于某一条时序路径才能决定触发器到底是发起数据还是捕获数据。例如，UFF3发起的数据如果被下一级触发器捕获了，那么在那条时序路径中UFF3则变为了发起触发器。

## 2.9 时钟域

在同步逻辑设计中，周期性的时钟信号将计算出的新数据锁存到触发器中。新的输入数据基于的是前一个时钟周期的触发器值，因此锁存到的数据将被用于计算下一个时钟周期的数据。

一个时钟通常驱动许多触发器，由同一时钟驱动的一组触发器称为其`时钟域（clock domain）`。在典型的设计中，可能有多个时钟域。例如，USBCLK驱动了200个触发器，而时钟MEMCLK驱动了1000个触发器，如图2-20所示。在此示例中，我们称有两个时钟域。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-5070e0f3e5f8499854378e512f4c56d8_1440w.jpg)图2-20

需要关注一个问题：两个时钟域是相关的还是彼此独立的？答案取决于是否存在一条从一个时钟域开始并在另一时钟域结束的数据路径，如果没有这样的路径，我们可以肯定地说这两个时钟域彼此独立，这意味着没有时序路径从一个时钟域开始而在另一时钟域结束。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-590e76815ceb15c697610d14515a31a7_1440w.jpg)图2-21

若存在跨时钟域的数据路径（如图2-21所示），则必须确定这些路径是否为真实（real）路径。例如，一个两倍频时钟驱动的触发器发起数据，再由一倍频时钟驱动的触发器捕获数据，这条路径就是一条真实路径。伪路径（false path）的一个例子是设计人员将时钟同步器（clock synchronizer）逻辑明确放置在两个时钟域之间。在这种情况下，即使好像存在从一个时钟域到下一时钟域的时序路径，但这也不是真实的时序路径，因为数`据没有被约束要在一个时钟周期之内通过同步器逻辑传播。这样的路径称为伪路径（不是真实的）`，因为是由时钟同步器来确保数据正确地从一个时钟域传递到另一个时钟域。可以使用**set_false_path**命令指定时钟域之间的伪路径，例如：

**set_false_path -from** [**get_clocks** USBCLK] \  **-to** [**get_clocks** MEMCLK]

虽然无法从图2-21中看到，但实际出现跨时钟域的情况往往是双向的，即从USBCLK时钟域到MEMCLK时钟域，以及从MEMCLK时钟域到USBCLK时钟域，这两种情况都需要在STA中正确理解和处理。

为什么要讨论时钟域之间的路径呢？通常，一个设计中会有多个时钟，并且时钟域之间可能有无数条路径。 分辨出哪些跨时钟域路径是真实的，哪些是伪路径，是时序验证工作的重要组成部分，这使得设计人员可以专注于验证真实的时序路径。

图2-22给出了时钟域的另一个示例，多路复用器（multiplexer）根据设计的工作模式选择时钟源。虽然只有一个时钟域，但却有两个时钟，这两个时钟是互斥的，因为一次只有一个时钟处于有效状态。因此，在这个例子中，USBCLK和USBCLKx2这两个时钟域之间永远不会存在时序路径（假定多路复用器的控制是静态的，并且设计中其余部分也不存在这两个时钟域之间的时序路径）。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-066a7d80cf987dfc20864234d649241d_1440w.jpg)图2-22

## 2.10 工作条件

静态时序分析通常是在特定的工作条件（operating condition）下执行的，工作条件定义为`工艺（process）、电压（voltage）和温度（temperature）的组合，简称PVT`。逻辑单元延迟和互连线的走线延迟是根据特定的工作条件计算的。

半导体代工厂（foundry）为数字设计提供了3种加工工艺模型：`慢速（slow）工艺模型，典型（typical）工艺模型和快速（fast）工艺模型`，快速和慢速工艺模型代表了半导体代工厂加工的两个极端`工艺角（process corner）`。==对于稳健（robust）的设计，应该在极端加工工艺角以及温度和电源电压都比较极端的环境下对设计进行验证==。图2-23（a）展示了逻辑单元延迟如何随工艺角变化；图2-23（b）展示了逻辑单元延迟如何随电源电压变化；图2-23（c）展示了逻辑单元延迟如何随温度变化。因此，为静态时序分析选择特定的工作条件是非常重要的。

![img](docs/IC/25-STA/SAT时序圣经%20翻译/02STA概念/v2-d28be4c789c1e86d5aaf8ed2984b7c86_1440w.jpg)

图2-23

为STA选择合适的工作条件还需要考虑到可用的单元库（cell library），3种标准的工作条件如下所示：

（1）**WCS**（Worst-Case Slow）：工艺慢（slow）、温度最高（例如125°C）并且电压最低（例如额定1.2V减去10％）。对于使用低电源的纳米技术，可能还有另一个最坏的情况：工艺慢、电压最低并且温度也最低。低温下的延迟并不总是小于高温下的延迟，这是因为对于纳米技术而言，相对于电源的器件阈值电压（Vt）裕度降低了。在这种低电源的情况下，负载较小的逻辑单元的延迟在低温下要高于在高温下的延迟。 对于高Vt（较高阈值，较大延迟）甚至是标准Vt（常规阈值，较低延迟）的单元，情况尤其如此。在较低温度下延迟增加的这种异常行为称为温度反转（temperature inversion），参见图2-23（c）。

（2）**TYP**（Typical）：典型（typical）工艺，温度是额定值（例如25°C），电压是额定值（例如1.2V）。

（3）**BCF**（Best-Case Fast）：工艺快（fast），温度最低（例如-40°C），电压最高（例如额定1.2V加10％）。

功耗分析（power analysis）的工作条件通常不同于静态时序分析所使用的工作条件。 对于功耗分析，工作条件可能是：

（1）**ML**（Maximal Leakage）：工艺快，温度最高（例如125°C），电压也最高（例如1.2V加10％）。该工作条件有最大的漏电功耗（leakage power），对于大多数设计，也有着最大的有效功耗（active power）。

（2）**TL**（Typical Leakage）：经典工艺，温度最高（例如125°C），电压是额定值（例如1.2V）。该工作条件下的漏电功耗比较具有代表性，因为由于正常工作时的功耗，芯片温度往往会更高。

静态时序分析基于的是设计人员所加载（load）和链接（link）的库，可以使用**set_operating_conditions**命令明确指定设计的工作条件。

**set_operating_conditions** “WCCOM” -library mychip

上述命令使用了在单元库mychip中定义的名为WCCOM的工作条件。

单元库可在各种工作条件下使用，选择何种工作条件进行分析取决于为STA加载的单元库。

