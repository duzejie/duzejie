RTL级，registertransferlevel，指的是用寄存器这一级别的描述方式来描述电路的数据流方式；而Behavior级指的是仅仅描述电路的功能而能够采用任何verilog语法的描述方式。鉴于这个区别，RTL级描述的目标就是可综合，而行为级描述的目标就是实现特定的功能而没有可综合（可实现）的限制。

行为级是RTL的上一层，行为级是最符合人类逻辑思惟方式的描述角度，通常基于算法，用C/C++来描述。从行为级到RTL级的转换，通常都是由IC设计人员手工翻译。

这个过程繁琐，工做量很大，特别是随着数字系统的复杂性提高，这样的纯手工"翻译"过程容易出错，且使得开发周期变长。一批高级综合工具应运而生。如Menter Graphics的高层次综合工具Catapult C Synthesis。可以将数字系统的行为级描述映射为RTL设计，并知足给定的目标限制。从层次由上到下，数字系统的设计过程为：

Idea->行为级描述->rtl描述->门级网标->物理版图设计

行为级的描述更多的是采起直接赋值的形式，只能看出结果，看不出数据流的实际处理过程。其中又大量采用算术运算，延迟等一些没法综合的语句。经常只用于验证仿真。

RTL级的描述就会更详细一些，而且从寄存器的角度，把数据的处理过程表达出来。能够容易地被综合工具综合成电路的形式。

行为级描述但是RTL的上层描述，比RTL更抽象。行为描述不关心电路的具体结构，只关注算法。

有行为综合工具，能够直接将行为级的描述综合为RTL级的，好比Behavioral Compiler。

在硬件设计中有一句著名的话：thinking of hardware。RTL在很大程度上是对流水线原理图的描述。哪里是组合逻辑，哪里是寄存器，设计者应该了然于胸。组合逻辑到底如何实现，取决于综合器和限制条件。

rtl级能够理解为，能够直接给综合工具生成你要的网表的代码，而行为级则不行。好比real(浮点实数？)能够用于行为级，而不能用于rtl级！

Behavior is for testbench for modelling.

RTL is for synthesis

语法块若是能够被综合到gate level，就是RTL的。不然就是behavior level的。

一样是for语句，若是循环条件是常数，就是RTL的，若是是变量，就是behavior的。

RTL级描述数据在寄存器层次的流动模型。

always属于行为级模型，是最基本的行为模型，是能够综合的。

综合与RTL或者行为级没有必然联系，虽然大多数行为模型不能综合

目的区别：

行为级描述目的是加快仿真速度，作法是尽可能减小一个always块中要执行的语句数量，其结果不是为了综合，只关注算法。有行为综合工具，能够直接将行为级的描述综合为RTL级的，好比Behavioral Compiler。

形式区别：

RTL级描述是为了综合工具可以正确的识别而编写的代码，verilog中有一个可综合的子集，不一样的综合工具支持的也有所不一样，RTL级的描述就会更详细一些，而且从寄存器的角度，把数据的处理过程表达出来。能够容易地被综合工具综合成电路的形式。能够采用任何verilog语法的描述方式。鉴于这个区别，RTL级描述的目标就是可综合，

行为级的描述更多的是采起直接赋值的形式，只能看出结果，看不出数据流的实际处理过程。其中又大量采用算术运算，延迟等一些没法综合的语句。经常只用于验证仿真。

电路区别：

RTL级，register transfer level，指的是用寄存器这一级别的描述方式来描述电路的数据流方式；RTL在很大程度上是对流水线原理图的描述。哪里是组合逻辑，哪里是寄存器，设计者应该了然于胸。组合逻辑到底如何实现，取决于综合器和限制条件。RTL是晶体管传输级，描述硬件的相互联接关系，通常均可以综合；

而Behavior级指的是仅仅描述电路的功能而在硬件设计中有一句著名的话：thinking of hardware。简单说，rtl就是用寄存器和组合逻辑组成，不能再用其余construct；behavior就是指定输入和输出之间的关系。

混乱点:有时感受RTL级是行为级与数据流级的混合应用。

乐点：一样是for语句，若是循环条件是常数，就是RTL的，若是是变量，就是behavior的。