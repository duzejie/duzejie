卷积神经网络有一个批量过滤器, 持续不断的在图片上滚动收集图片里的信息,每一次收集的时候都只是收集一小块像素区域, 然后把收集来的信息进行整理, 这时候整理出来的信息有了一些实际上的呈现, 比如这时的神经网络能看到一些边缘的图片信息, 然后在以同样的步骤, 用类似的批量过滤器扫过产生的这些边缘信息, 神经网络从这些边缘信息里面总结出更高层的信息结构,比如说总结的边缘能够画出眼睛,鼻子等等. 再经过一次过滤, 脸部的信息也从这些眼睛鼻子的信息中被总结出来. 最后我们再把这些信息套入几层普通的全连接神经层进行分类, 这样就能得到输入的图片能被分为哪一类的结果了.

##  {#conv1d}

## Conv1D层 {#conv1d}

---

一维卷积层（即时域卷积），用以在一维输入信号上进行邻域滤波。当使用该层作为首层时，需要提供关键字参数`input_shape`。例如`(10,128)`代表一个长为10的序列，序列中每个信号为128向量。而`(None, 128)`代表变长的128维向量序列。

该层生成将输入信号与卷积核按照单一的空域（或时域）方向进行卷积。如果`use_bias=True`，则还会加上一个偏置项，若`activation`不为None，则输出为经过激活函数的输出。

## Conv2D层 {#conv2d}

---

二维卷积层，即对图像的空域卷积。该层对二维输入进行滑动窗卷积，当使用该层作为第一层时，应提供`input_shape`参数。例如`input_shape = (128,128,3)`代表128\*128的彩色RGB图像（`data_format='channels_last'`）

## SeparableConv2D层 {#separableconv2d}

---

该层是在深度方向上的可分离卷积。

可分离卷积首先按深度方向进行卷积（对每个输入通道分别卷积），然后逐点进行卷积，将上一步的卷积结果混合到输出通道中。参数`depth_multiplier`控制了在depthwise卷积（第一步）的过程中，每个输入通道信号产生多少个输出通道。

直观来说，可分离卷积可以看做讲一个卷积核分解为两个小的卷积核，或看作Inception模块的一种极端情况。

当使用该层作为第一层时，应提供`input_shape`参数。例如`input_shape = (3,128,128)`代表128\*128的彩色RGB图像

## Conv2DTranspose层 {#conv2dtranspose}

---

该层是转置的卷积操作（反卷积）。需要反卷积的情况通常发生在用户想要对一个普通卷积的结果做反方向的变换。例如，将具有该卷积层输出shape的tensor转换为具有该卷积层输入shape的tensor。同时保留与卷积层兼容的连接模式。

当使用该层作为第一层时，应提供`input_shape`参数。例如`input_shape = (3,128,128)`代表128\*128的彩色RGB图像

## Conv3D层 {#conv3d}

---

`input_shape`参数。例如`input_shape = (3,10,128,128)`代表对10帧128\*128的彩色RGB图像进行卷积。数据的通道位置仍然有`data_format`参数指定。

## Cropping1D层 {#cropping1d}

---

在时间轴（axis1）上对1D输入（即时间序列）进行裁剪

## Cropping2D层 {#cropping2d}

---

对2D输入（图像）进行裁剪，将在空域维度，即宽和高的方向上裁剪

## Cropping3D层 {#cropping3d}

---

对2D输入（图像）进行裁剪

## UpSampling1D层 {#upsampling1d}

---

在时间轴上，将每个时间步重复`length`次

## UpSampling2D层 {#upsampling2d}

---

将数据的行和列分别重复size\[0\]和size\[1\]次

## UpSampling3D层 {#upsampling3d}

---

将数据的三个维度上分别重复size\[0\]、size\[1\]和ize\[2\]次

本层目前只能在使用Theano为后端时可用

## ZeroPadding1D层 {#zeropadding1d}

---

对1D输入的首尾端（如时域序列）填充0，以控制卷积以后向量的长度

## ZeroPadding2D层 {#zeropadding2d}

---

对2D输入（如图片）的边界填充0，以控制卷积以后特征图的大小

## ZeroPadding3D层 {#zeropadding3d}

---

将数据的三个维度上填充0

本层目前只能在使用Theano为后端时可用

