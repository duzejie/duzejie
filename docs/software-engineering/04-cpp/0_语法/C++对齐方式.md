---
title: C++对齐方式
author: Sunglow
top: false
cover: false
toc: false
mathjax: false
summary: 'null'
categories:
  - 软件工程
  - Cpp
tags:
  - 编程
  - C++
date: 2018-02-22 21:25:13
keywords:
---

## C++对齐方式

编译器要对c++代码进行编译时需要按照相应的类型为变量分配内存空间，最为人们熟知的就是那五个空间了：栈，堆，全局数据区，常量区和代码区。现在知道了哪些变量存放在哪些空间里了，但是在相应的空间里又是如何存放的呢？   


## gcc linux 或默认字节对齐方式
字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：
1. 结构体变量的首地址能够被其最宽**基本**类型成员的大小所整除；
2. 结构体每个成员相对于结构体首地址的偏移量都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；
3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

说明：  

1. 基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；  
1. 对于复合数据类型，如结构体嵌套结构体，那么基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；  
1. 我认为计算结构体大小的时候，主要用到准则2和准则3，对于准则1是编译器自动完成的，不需要过多理会。  
1. C++中类的可以看做是特殊的结构体，所以类的sizeof的计算和结构体是一样的。



-----------------------------------------------------



windows 对齐方式有三种规则，看网上已经很详细了，我还是想用自己的话再说一遍吧：  


### 1. 数据成员对齐规则： 
内存为类，结构体或联合体分配内存时，首先可以确定这些对象的首地址，类、结构体或联合体的的成员变量在内存从相对于首地址的offset=0处开始分配内存，分配时遵循如下原则：比较这个变量的类型所占字节数m和#paragma pack(n)中指定的n的大小，   
如果m>n，用offset%n，
如果m<n，用offset%m,   
	如果结果==0，那么此变量便分配在以offset为偏移地址的m个字节处，offset+=m;    
	如果结果！=0，那么采用补齐原则，offset一直加到%m为0时为止，然后再以此时的offset为偏移地址，分配此变量，最后offset+=m;   


### 2. 结构(或联合)的整体对齐规则：    
在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。   

###  3. 含有对象组合的对齐规则：   
各个基本类型成员的对齐方式是不变的，遇到对象的情况下，要在符合这个对象中各个数据类型的字节数的公倍数进行对齐，否则，可能会导致对象内部不对齐。   

下面用网上的例子和我的改进加以说明        

试验：通过#pragma pack(n)改变“对齐系数”，然后察看sizeof(struct test_t)的值。       

 1字节对齐(#pragma pack(1))

输出结果：sizeof(struct test_t) = 8
分析过程：
1) 成员数据对齐

```
#pragma pack(1)
struct test_t {
 int a;  /* 长度4 > 1 按1对齐；起始offset=0 0%1=0；存放位置区间[0,3] */
 char b;  /* 长度1 = 1 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */
 short c; /* 长度2 > 1 按1对齐；起始offset=5 5%1=0；存放位置区间[5,6] */
 char d;  /* 长度1 = 1 按1对齐；起始offset=7 7%1=0；存放位置区间[7] */
};
```

#pragma pack()
成员总大小=8

 2) 整体对齐      
整体对齐系数 = min((max(int,short,char), 1) = 1
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 8 /* 8%1=0 */ 

2字节对齐(#pragma pack(2))      

输出结果：sizeof(struct test_t) = 10     

分析过程：

1) 成员数据对齐
```
#pragma pack(2)
struct test_t {
 int a;  /* 长度4 > 2 按2对齐；起始offset=0 0%2=0；存放位置区间[0,3] */
 char b;  /* 长度1 < 2 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */
 short c; /* 长度2 = 2 按2对齐；offset 需要按照原则1自增，直到起始offset=6 6%2=0；存放位置区间[6,7] */
 char d;  /* 长度1 < 2 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */
};
#pragma pack()
成员总大小=9
```
2) 整体对齐
整体对齐系数 = min((max(int,short,char), 2) = 2
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 10 /* 10%2=0 */

4字节对齐(#pragma pack(4))


输出结果：sizeof(struct test_t) = 12
分析过程：
1) 成员数据对齐
```
#pragma pack(4)
struct test_t {
 int a;  /* 长度4 = 4 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */
 char b;  /* 长度1 < 4 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */
 short c; /* 长度2 < 4 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */
 char d;  /* 长度1 < 4 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */
};
#pragma pack()
成员总大小=9
```
 2) 整体对齐  

整体对齐系数 = min((max(int,short,char), 4) = 4
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */

 8字节对齐(#pragma pack(8))

输出结果：sizeof(struct test_t) = 12

分析过程：

1) 成员数据对齐

```
#pragma pack(8)

struct test_t {

 int a;  /* 长度4 < 8 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */

 char b;  /* 长度1 < 8 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */

 short c; /* 长度2 < 8 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */

 char d;  /* 长度1 < 8 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */

};

#pragma pack()

成员总大小=9
```
2) 整体对齐

整体对齐系数 = min((max(int,short,char), 8) = 4

整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */

 

16字节对齐(#pragma pack(16))

输出结果：sizeof(struct test_t) = 12

分析过程：

1) 成员数据对齐
```
#pragma pack(16)

struct test_t {

 int a;  /* 长度4 < 16 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */

 char b;  /* 长度1 < 16 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */

 short c; /* 长度2 < 16 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */

 char d;  /* 长度1 < 16 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */

};

#pragma pack()

成员总大小=9
```
 2) 整体对齐

整体对齐系数 = min((max(int,short,char), 16) = 4

整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */



输出结果：sizeof(struct test_t) = 1