### 1. C++的内存管理
在C++中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区
- 栈：存放函数的参数和局部变量，编译器自动分配和释放
- 堆：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收
- 自由存储区：由malloc分配的内存，和堆十分相似，由对应的free进行释放
- 全局/静态存储区：存放全局变量和静态变量
- 常量区：存放常量，不允许被修改

### 1. 堆和栈的区别

1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放
	堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收
2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片
3）堆的生长空间向上，地址越大，栈的生长空间向下，地址越小

### 1. 引用作为函数参数以及返回值的好处

对比值传递，引用传参的好处：
1）在函数内部可以对此参数进行修改
2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。
