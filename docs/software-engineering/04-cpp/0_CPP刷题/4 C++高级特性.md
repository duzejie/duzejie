### 1. 左值和右值

### 1. C++11包含大量的新特性

包含lambda表达式，类型推导keyword : auto、decltype，和模板的大量改进。

- **decltype**实际上有点像auto的反函数，auto能够让你声明一个变量。而decltype则能够从一个变量或表达式中得到类型
- **nullptr**是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，由于NULL实际上代表的是0，
- 简化的for循环，能够用于遍历数组、容器、string以及由begin和end函数定义的序列（即有Iterator），for (auto p : m)
- **lambda表达式**，能够用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法例如以下：
	` [函数对象參数]（操作符重载函数參数）->返回值类型 {函数体}`
```cpp
vector<int> iv{5, 4, 3, 2, 1};  
int a = 2, b = 1;

for_each(iv.begin(), iv.end(), [b](int &x){cout<<(x + b)<<endl;}); // (1)
for_each(iv.begin(), iv.end(), [=](int &x){x *= (a + b);});     // (2)
for_each(iv.begin(), iv.end(), [=](int &x)->int{return x * (a + b);});// (3)
```
- \[ \]内的參数指的是Lambda表达式能够取得的全局变量。(1)函数中的b就是指函数能够得到在Lambda表达式外的全局变量，假设在[]中传入=的话，即是能够取得全部的外部变量，如（2）和（3）Lambda表达式
- ()内的參数是每次调用函数时传入的參数。
- ->后加上的是Lambda表达式返回值的类型。如（3）中返回了一个int类型的变量

- 变长參数的模板，C++11中引入了变长參数模板，所以发明了新的数据类型：tuple，tuple是一个N元组。能够传入1个， 2个甚至多个不同类型的数据

```cpp
auto t1 = make_tuple(1, 2.0, "C++ 11");  
auto t2 = make_tuple(1, 2.0, "C++ 11", {1, 0, 2});
```

避免了从前的pair中嵌套pair的丑陋做法。使得代码更加整洁

- 更加优雅的初始化方法

在引入C++11之前。仅仅有数组能使用初始化列表，其它容器想要使用初始化列表，仅仅能用下面方法：

```cpp
int arr[3] = {1, 2, 3}  
vector<int> v(arr, arr + 3);
```

在C++11中，我们能够使用下面语法来进行替换：

```cpp
int arr[3]{1, 2, 3};  
vector<int> iv{1, 2, 3};  
map<int, string>{{1, "a"}, {2, "b"}};  
string str{"Hello World"};
```

### 1. 什么是智能指针？智能指针的原理

- 将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。
- 智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放，
- 智能指针就是一种栈上创建的对象，函数退出时会调用其析构函数，这个析构函数里面往往就是一堆计数之类的条件判断，如果达到某个条件，就把真正指针指向的空间给释放了。

注意事项：

不能将指针直接赋值给一个智能指针，一个是类，一个是指针。

常用的智能指针

智能指针在C++11版本之后提供，包含在头文件\<memory\>中，shared_ptr、unique_ptr、weak_ptr

1）std::auto_ptr，有很多问题。 不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。所以可能会造成程序崩溃，比如

```cpp
auto_ptr<string> p1(new string ("auto") ； //#1  
auto_ptr<string> p2;                                    //#2  
p2 = p1;                                                        //#3
```

在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；

但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。如果再访问p1指向的内容则会导致程序崩溃。

auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，摒弃auto_ptr的原因，一句话总结就是：避免潜在的内存崩溃问题。

2) C++11引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。实在想赋值的话，需要使用：std::move。例如：

```cpp
std::unique_ptr<int> p1(new int(5))          // #4  
std::unique_ptr<int> p2 = p1; // 编译会出错         //#5  
std::unique_ptr<int> p3 = std::move(p1); // 转移所有权, 现在那块内存归p3所有, p1成为无效的指针. //#6
```

编译器认为语句#5非法，因此，unique_ptr比auto_ptr更安全。

但unique_ptr还有更聪明的地方。 有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做

```cpp
unique_ptr<string> pu1(new string ("hello world"));  
unique_ptr<string> pu2;  
pu2 = pu1;                                      // #1 not allowed  
unique_ptr<string> pu3;  
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。

3) C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。

4）C++11或boost的weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。

### 1. 智能指针的作用

C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，野指针，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

### 1. 多态， 虚函数， 纯虚函数

多态：不同对象接收相同的消息产生不同的动作。多态包括 编译时多态 和 运行时多态

运行时多态是：通过继承和虚函数来体现的。

编译时多态：运算符重载上。

封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。多态也有代码重用的功能，还有解决项目中紧耦合的问题，提高程序的可扩展性。C++实现多态的机制很简单，在继承体系下，将父类的某个函数给成虚函数（即加上virtual关键字），在派生类中对这个虚函数进行重写，利用父类的指针或引用调用虚函数。通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。对于虚函数调用来说，每一个对象内部都有一个虚表指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚表指针的初始化，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。

需要注意的几点总结（基类有虚函数）：

1、每一个类都有虚表，单继承的子类拥有一张虚表，子类对象拥有一个虚表指针；若子类是多重继承（同时继承多个基类），则子类维护多张虚函数表（针对不同基类构建不同虚表），该子类的对象也将包含多个虚表指针。

2、虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。

3、派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。
![[attachments/Pasted image 20230530112329.png]]

第一：编译器在发现Father 类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。

第二：编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。

第三：所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。

虚函数： 在基类中用virtual的成员函数。允许在派生类中对基类的虚函数重新定义。

基类的虚函数可以有函数体，基类也可以实例化。

虚函数要有函数体，否则编译过不去。

虚函数在子类中可以不覆盖。

构造函数不能是虚函数。

纯虚函数：基类中为其派生类保留一个名字，以便派生类根据需要进行定义。

包含一个纯虚函数的类是抽象类。

纯虚函数后面有 = 0；

抽象类不可以实例化。但可以定义指针。

如果派生类如果不实现基类的纯虚函数，则仍然是抽象类。

抽象类可以包含虚函数。

### 1. 虚函数是怎么实现的

每一个含有虚函数的类都至少有有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针（地址），

类的实例对象不包含虚函数表，只有虚指针；

派生类会生成一个兼容基类的虚函数表。

1. 纯虚函数

纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承

包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象

普通函数是静态编译的，没有运行时多态

### 1. 重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别

1）overload，将语义相近的几个函数用同一个名字表示，但是参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同

特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无

2）override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同

特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）

3）overwrite隐藏（重定义），派生类屏蔽了其同名的基类函数，返回值类型可以不同

特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字


