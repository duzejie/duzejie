### 1. c cc cpp hpp inl 这些后缀名都有什么区别?

C中：
	头文件后缀名： .h
	源文件后缀名： .c

C++中：
	头文件后缀名： .h, .hpp, .hxx
	源文件后缀名：.cpp, .cc, .cxx, .C .c++

- 只是个名称，我们自己知道哪些是同一个东西，能区别开c和c++就行了。
- 另外，.h和.hpp的区别是：\*.h里面只有声明，没有实现，而\*.hpp里声明实现都有，后者可以减少.cpp的数量，适合用来编写公用的开源库。
- inl 文件是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候内联函数较多或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体定义的代码添加到INL文件中，然后在该头文件的末尾将其用#include引入。由此也可以看到inl文件的例外一个用法的影子——模板函数、模板类的定义代码的存放。

### 1. \#include <file.h> \#include "file.h" 的区别

前者是从标准库路径寻找
后者是从当前工作路径

### 1. gcc 和 g++的区别

简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：
1. gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。
	`gcc main.cpp -lstdc++`

gcc编译的四个步骤, 以最简单的hello.c为例子
- 一步到位：gcc hello.c

这条命令隐含执行了
（1）预处理
（2）编译
（3）汇编
（4）链接

这里未指定输出文件，默认输出为a.out

- gcc编译C源码有四个步骤：
预处理 ----> 编译 ----> 汇编 ----> 链接
现在我们就用gcc的命令选项来逐个剖析gcc过程。

1）预处理(Pre-processing)
	在该阶段，编译器将C源代码中的包含的头文件如stdio.h添加进来
	参数：”-E”
	用法：gcc -E hello.c -o hello.i
	作用：将hello.c预处理输出hello.i文件。

2)编译(Compiling)
	第二步进行的是编译阶段，在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。
	参数：”-S”
	用法：gcc –S hello.i –o hello.s
	作用：将预处理输出文件hello.i汇编成hello.s文件。

3)汇编(Assembling)
	汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件
	参数：“-c”
	用法：gcc –c hello.s –o hello.o
	作用：将汇编输出文件hello.s编译输出hello.o文件。

4）链接(Link)
	在成功编译之后，就进入了链接阶段。
	用法：gcc hello.o –o hello
	作用：将编译输出文件hello.o链接成最终可执行文件hello。
	运行该可执行文件，出现正确的结果如下。

>>> ./hello

Hello World!

### 1. C++文件编译与执行的四个阶段

1）预处理：根据文件中的预处理指令来修改源文件的内容
2）编译：编译成汇编代码
3）汇编：把汇编代码翻译成目标机器指令
4）链接：链接目标代码生成可执行程序

### 1. C语言的函数调用过程

函数的调用过程：
	1）从栈空间分配存储空间
	2）从实参的存储空间复制值到形参栈空间
	3）进行运算
形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。
数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。
传值：传值，实际是把实参的值赋值给行参，相当于copy。那么对行参的修改，不会影响实参的值 。
传址： 实际是传值的一种特殊方式，只是他传递的是地址，不是普通的赋值，那么传地址以后，实参和行参都指向同一个对象，因此对形参的修改会影响到实参。

### 1. C和C++的区别

1）C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。
2）C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
3）C++支持函数重载，C不支持函数重载
4）C++中有引用，C中不存在引用的概念

### 1. 编译的过程 动态库和静态库的区别

来自 <[https://zhuanlan.zhihu.com/p/403329535](https://zhuanlan.zhihu.com/p/403329535)>






#### 手动编译

在命令行下输入 `g++ a.cpp` 就可以编译 `a.cpp` 这个文件了（Windows 系统需提前把编译器所在目录加入到 `PATH` 中）。

编译过程中可以加入一些编译选项：

-   `-o <文件名>`：指定编译器输出可执行文件的文件名。
-   `-g`：在编译时添加调试信息（使用 gdb 调试时需要）。
-   `-Wall`：显示所有编译警告信息。
-   `-O1`，`-O2`，`-O3`：对编译的程序进行优化，数字越大表示采用的优化手段越多（开启优化会影响使用 gdb 调试）。
-   `-DDEBUG`：在编译时定义 `DEBUG` 符号（符号可以随意更换，例如 `-DONLINE_JUDGE` 定义了 `ONLINE_JUDGE` 符号）。
-   `-UDEBUG`：在编译时取消定义 `DEBUG` 符号。
-   `-lm`，`-lgmp`: 链接某个库（此处是 math 和 gmp，具体使用的名字需查阅库文档，但一般与库名相同）。

> [!note]
    在 Unix 下，如使用了标准 C 库里的 math 库（`math.h`），则需在编译时添加 `-lm` 参数。[^have-to-link-libm-in-gcc]

#### 使用 GNU Make 的内置规则[^gnu-make-built-in-rules]

对于名为 `qwq.c/cpp/p` 的 C，C++，Pascal 程序源代码，可以使用 `make qwq` 自动编译成对应名为 `qwq` 的程序。

如需添加额外的编译选项，请使用 `export CFLAGS="xxx"` 或者 `export CPPFLAGS="xxx"` 定义。