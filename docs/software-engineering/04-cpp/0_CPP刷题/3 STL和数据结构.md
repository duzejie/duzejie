# STL

### 1. C++模板的作用

模板（Template）指C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。通常有两种形式：函数模板和类模板；

### 1. STL库用过吗？常见的STL容器有哪些？算法用过几个？

STL包括两部分内容：容器和算法

- 容器即存放数据的地方，比如array, vector，分为两类，序列式容器和关联式容器

序列式容器，其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist

关联式容器，内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set

- 算法有排序，复制等，以及各个容器特定的算法

迭代器是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。

### 1. STL中map和set的原理（关联式容器）

map和set的底层实现主要通过红黑树来实现

红黑树是一种特殊的二叉查找树

1）每个节点或者是黑色，或者是红色

2）根节点是黑色

3） 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]

4）如果一个节点是红色的，则它的子节点必须是黑色的

5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

特性4）5）决定了没有一条路径会比其他路径长出2倍，因此红黑树是接近平衡的二叉树。

### 1. STL中的vector的实现，是怎么扩容的？

vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。

vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。

vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。

在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。

### 1. STL中unordered_map和map的区别

map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。

unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。

### 1. 构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？

1、构造函数不能声明为虚函数

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

2、析构函数最好声明为虚函数

首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

### 1. 子类析构时，要调用父类的析构函数吗？

析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。

不用显式调用，会自动调用

### 1. 静态绑定和动态绑定的介绍

静态绑定和动态绑定是C++多态性的一种特性

1）对象的静态类型和动态类型

静态类型：对象在声明时采用的类型，在编译时确定

动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改

2）静态绑定和动态绑定

静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定

动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定

只有虚函数才使用的是动态绑定，其他的全部是静态绑定

### 1. 引用是否能实现动态绑定，为什么引用可以实现

可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。

### 1. 深拷贝和浅拷贝的区别

深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。

### 1. 什么情况下会调用拷贝构造函数（三种情况）

系统自动生成的构造函数：普通构造函数和拷贝构造函数 （在没有定义对应的构造函数的时候）

生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数

调用拷贝构造函数的情形：

1）用类的一个对象去初始化另一个对象的时候

2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用

3）当函数的返回值是类的对象或者引用的时候

举例：

```cpp

#include <iostream>  
#include <string>  
using namespace std;  
class A{  
        private:  
                int data;  
        public:  
                A(int i){ data = i;}         //自定义的构造函数                A(A && a);                          //拷贝构造函数                int getdata(){return data;}  
};  
//拷贝构造函数  
A::A(A && a){  
        data = a.data;  
        cout <<"拷贝构造函数执行完毕"<<endl;  
}  
//参数是对象，值传递，调用拷贝构造函数  
int getdata1(A a){  
        return a.getdata();  
}  
//参数是引用，引用传递，不调用拷贝构造函数  
int getdata2(A &a){  
        return a.getdata();  
}  
//返回值是对象类型，会调用拷贝构造函数 A getA1(){  
         A a(0);  
         return a;  
 } //返回值是引用类型，会调用拷贝构造函数，因为函数体内生成的对象是临时的，离开函数就消失 A& getA2(){  
         A a(0);  
         return a;  
 }  
 int main(){  
    A a1(1);   
    A b1(a1);                           //用a1初始化b1，调用拷贝构造函数     A c1=a1;                            //用a1初始化c1，调用拷贝构造函数     int i=getdata1(a1);                //函数形参是类的对象，调用拷贝构造函数     int j=getdata2(a1);              //函数形参类型是引用，不调用拷贝构造函数     A d1=getA1();                       //调用拷贝构造函数     A e1=getA2();                             //调用拷贝构造函数     return 0;   
} 
```


### 1. C++标准库vector以及迭代器

每种容器类型都定义了自己的迭代器类型，每种容器都定义了一队命名为begin和end的函数，用于返回迭代器。

迭代器是容器的精髓，它提供了一种方法使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。

### 1. C++中vector和list的区别

vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。

list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。

vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。

list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等

vector<int>::iterator和list<int>::iterator都重载了“++”运算符。

总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;

如果需要大量的插入和删除，而不关心随机存取，则应使用list。

### 1. 友元函数和友元类

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。

通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。

友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

1）友元函数

有元函数是可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，不属于任何类，但是需要在类的定义中加以声明。

friend 类型 函数名(形式参数);

一个函数可以是多个类的友元函数，只需要在各个类中分别声明。

2）友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。

friend class 类名;

使用友元类时注意：

(1) 友元关系不能被继承。

(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。

(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

# 算法库

### 1. c++函数库<algorithm>中一些实用的函数

1. __gcd(x, y)

求两个数的最大公约数，如__gcd(6, 8) 就返回2。

### 2. reverse(a + 1, a + n + 1)

将数组中的元素反转。a 是数组名，n是长度，跟 sort 的用法一样。值得一提的是，对于字符型数组也同样适用。

### 3. unique(a + 1, a + n + 1)

去重函数。跟sort的用法一样。不过他返回的值是最后一个数的地址，所以要得到新的数组长度应该这么写： _n = unique(a + 1, a + n + 1) - a - 1.

### 4.lower_bound(a + 1, a + n + 1, x); upper_bound(a + 1, a + n + 1, x)

lower_bound是查找数组中第一个大于等于x的数，返回该地址，同理也是 pos = lower_bound(a + 1, a + n + 1, x) - a

upper_bound是查找第一个大于x的数，用法和lower_bound一样

复杂度是二分的复杂度，O(logn)。（其实就是代替了手写二分）

### 5.fill(a + 1, a + n + 1, x)

例如

```cpp
//int数组：
fill(arr, arr + n, 要填入的内容);
//vector也可以：
fill(v.begin(), v.end(), 要填入的内容);
fill(vector.begin(), cnt, val); // 从当前起始点开始，将之后的cnt个元素赋值为val。
memset(arr, val, cnt); // 在头文件<cstring>里。
```


将数组a中的每一个元素都赋成x，跟memset的区别是，memset函数按照字节填充，所以一般memset只能用来填充char型数组，（因为只有char型占一个字节）如果填充int型数组，除了0和-1，其他的不能。